콘텐츠로 건너뛰기
채팅 기록




나의 말:
이 두 웹사이트를 최대한 자세히 학습해주세요.
현재도 이미 방송 중이 아니더라도 치즈(도네이션)를 쏘는 기능은 가능하며,
단, 채팅창 설정에 따라 도네이션이 채팅창에도 남는지 어떤지는 확인해봐야 합니다.

저는 외부 인터페이스를 이용하되, 인터페이스를 이용하는 동안 해당 유저가 네이버 치지직에 체류하고 있는 것으로 취급하고 (네이버 측이 원하는 지표이므로)
언제든지 치즈를 메시지와 함께 쏠 수 있는 간단한 웹앱을 구상하고 있습니다
화면은 일단 모바일에만 최적화시키고 웹사이트에도 양옆을 마스킹해서 제공할 거구요

현재 채팅창 설정과 상관없이 치즈를 쏘면 내부 인터페이스를 통해 메시지를 한번 더 노출시킵니다.

치즈로 보낸 메시지는 모두에게 보입니다.
스트리머가 쓴 메시지도 모두에게 보입니다.

시청자(일반유저)가 쓴 메시지는 스트리머에게는 보이지만 일반유저끼리는 볼 수 없습니다.
스트리머는 일반유저의 메시지에는 답을 할 수 있습니다.
또는 일반유저의 메시지가 모든 사람들에게 보이도록 RT할 수 있습니다.

이 웹앱의 가장 큰 특징은
방송 시간 이후에도 후원을 받을 수 있도록 한 것이며,
방송 시간 이후에도 수익원을 만들기 위한 것입니다.

더불어, 방송인은 방송 외적으로도 치즈를 받을 수 있게 되므로,
더 체계적으로 어떤 유저가 나한테 치즈를 많이 주는지, 언제 많이 들어오는지 등을 계산할 수 있으며, (방송 중이든 방송 후든, 나에게 온 치즈 액수나 메시지를 모아서 볼 수 있는 기능)
치즈 액수에 따른 '자체 뱃지' 를 제작하여 앱 인터페이스 내에서 보이도록 할 수 있습니다.

추후에는 '뱃지별 컨텐츠' 를 마련하는 방식도 생각하고 있습니다.

장기적으로는 '치즈 선정산' 서비스를 제공할 예정입니다.

현재 생각중인 이름은 '멜트(Melt)' 입니다.

1. 이 서비스에 대해 스트리머들, 청자들 양쪽에게 소구할 수 있는 소개글을 써 주세요. 실제로 있는 서비스처럼요. 단, 위의 모든 내용이 포함되어 있어야 합니다.

2. 아래의 두 가지 링크는 각각 치지직 api 링크, 오픈소스 프로젝트들을 모아 놓은 링크입니다. 위 서비스의 구조와 기능을 정의하고, 개발이 가능한지, 주로 어떤 권한이나 어떤 api가 필요한지, 유저한테서는 (당연히 네이버 로그인으로 멜트도 로그인시킨다는 전제 하에) 어떤 권한들을 받아놔야 하는지 등을 아주 자세하면서도 이해하기 쉽게 알려주세요.

https://chzzk.gitbook.io/chzzk
https://github.com/dokdo2013/awesome-chzzk
ChatGPT의 말:

49s 동안 생각함
아래는 (1) Melt 소개글(스트리머/시청자 양쪽 버전) + (2) CHZZK 공식 Open API/오픈소스 생태계를 기준으로 “이걸 실제로 어떻게 만들 수 있는지”를 기능/권한/API/로그인 스코프 관점에서 최대한 구체적으로 정리한 내용입니다. (요청하신 “방송 중이 아니어도 치즈를 쏠 수 있음”은 치지직 고객센터 문서에서 방송 종료 후에도 미션이 채널에 노출/판정될 수 있음이 명시되어 있어, 방송 외 시간 후원 UX를 설계할 여지가 있다는 근거로 함께 반영했습니다. 
)

1) Melt 소개글 (실서비스처럼, 요청하신 정책/동작 포함)
A. 스트리머에게 (Creator-facing)
**Melt(멜트)**는 “방송이 꺼진 뒤에도 후원이 흐르도록” 설계된 치지직 기반 후원·메시지 웹앱입니다.
라이브 중이 아니어도, 팬은 언제든지 치즈(도네이션) + 메시지를 보낼 수 있고, 스트리머는 방송 밖 시간에도 수익원과 팬 커뮤니케이션을 이어갈 수 있습니다. 

Melt의 메시지 노출 방식은 단순합니다.

치즈로 보낸 메시지 = 모두에게 공개 (Melt 피드에 전체 공개)

스트리머가 쓴 메시지 = 모두에게 공개

일반 시청자 메시지 = 스트리머에게만 보이는 1:1(비공개) 메시지

스트리머는 비공개 메시지에 답장할 수 있고,

필요하면 해당 메시지를 RT(리트윗)처럼 “전체 공개”로 전환할 수 있습니다.

또한 Melt는 치지직의 채팅창 설정과 무관하게, 치즈 후원 시 Melt 내부 UI에서 메시지를 한 번 더 확실히 노출합니다.
(채팅창에 후원 메시지가 남는지는 치지직 채팅 설정/정책에 따라 달라질 수 있어도, Melt에서는 “보이게” 설계합니다.)

마지막으로, Melt는 방송인의 운영을 “데이터”로 바꿉니다.

방송 중/방송 후를 가리지 않고 내 채널에 들어온 치즈·메시지를 한 곳에 모아보기

“누가/언제/얼마나”를 기반으로 후원 상위 유저, 시간대별 유입, 누적 랭킹을 계산

치즈 누적 액수에 따른 **Melt 전용 ‘자체 뱃지’**를 제작/노출

장기적으로는 뱃지별 전용 콘텐츠(권한형 콘텐츠) 운영까지 확장

그리고 궁극적으로 ‘치즈 선정산’(캐시플로우/정산 서비스) 로 이어지는 로드맵

Melt = 방송이 꺼진 시간까지 수익화하는 “After-live monetization layer” 입니다.

B. 시청자에게 (Viewer-facing)
**Melt(멜트)**는 좋아하는 스트리머에게 “방송 중이 아니어도” 응원을 전달할 수 있는 초간단 모바일 후원 앱입니다.

언제든지 치즈 + 메시지로 응원 가능

내가 보낸 치즈 메시지는 모두에게 공개되어 “응원 기록”이 남고,

스트리머의 답장도 모두에게 공개되어 “함께 보는 소통”이 됩니다.

반대로, 그냥 하고 싶은 말이 있을 때는 비공개 메시지로 스트리머에게만 전달할 수도 있어요.
스트리머가 답장을 하거나, 좋은 사연은 RT로 전체 공개될 수 있습니다.

Melt는 모바일 UI에 최적화되어 있고(웹에서는 좌우 마스킹으로 모바일 화면을 그대로 제공), 치지직 밖에서 쓰더라도 로그인/유저 흐름을 치지직 생태계와 연결해 “치지직에 머무는 경험”에 가깝게 설계됩니다.

2) “가능한 구조인가?” — CHZZK Open API/오픈소스 기준 기술·권한·API 요구사항
먼저 결론 (가장 중요)
(A) Melt 내부의 ‘공개 피드/비공개 메시지/RT’는 100% Melt 서버/DB로 구현 가능합니다. (치지직 채팅과 별개)

(B) 다만 ‘치즈 결제/후원 보내기’를 Open API로 직접 실행하는 공식 엔드포인트는 문서 상 확인되지 않습니다.
공식 문서에서 확인되는 것은 주로 채팅 전송/공지/채팅설정, 그리고 후원 이벤트 구독 및 후원 조회(스트리머 측) 같은 “읽기/운영” 성격입니다. 

→ 따라서 “치즈를 보내는 UX”는 보통 치지직의 결제/후원 페이지(공식 웹 플로우)로 연결하거나, 치지직이 제공하는 후원 UI/딥링크/웹뷰 흐름을 활용하는 방향이 현실적입니다. (이 부분은 공식 문서에 ‘후원 실행 API’가 없는 한 거의 확정적인 제약입니다.)

(C) 방송 종료 후 후원 UX는 치지직 고객센터 문서에서 “방송 종료 후에도 미션이 채널에 노출/판정될 수 있음”이 명시되어 있어, 방송 외 시간에 후원을 이어붙이는 제품 기획 자체는 UX 관점에서 정합성이 있습니다. 

2-1. Melt 권한/로그인: 무엇을 받아야 하나?
(1) 필수: 치지직 OAuth 로그인 (멜트 로그인 = 네이버/치지직 계정 연동)
치지직 Open API는 OAuth 기반이며,

인증 코드 요청 도메인: https://chzzk.naver.com/account-interlock

토큰 발급/갱신/폐기: POST /auth/v1/token, POST /auth/v1/token/revoke

Access Token(1일), Refresh Token(30일) 

즉 Melt는 최소한:

clientId / clientSecret을 가진 “치지직 Open API 앱”으로 등록

Redirect URI 설정

로그인 시 Authorization Code → Access/Refresh Token 교환

토큰 저장/갱신 로직
이 필요합니다. 

(2) 필수 스코프(권장 최소 세트)
Melt가 “유저 식별 + 내 채널/스트리머 채널 연결 + 후원 집계”를 하려면 보통 아래가 최소입니다.

유저 정보 조회: 로그인 유저의 채널 ID/채널명 확보
GET /open/v1/users/me 

후원 조회(스트리머 데이터 집계용): 문서상 “세션/이벤트 구독(후원)” 및 “후원 조회 스코프”가 존재 

(선택) 채팅 관련 스코프: 채팅 메시지 전송/공지/설정 조회·변경은 가능 

다만, Melt의 핵심 UX가 “치지직 채팅과 무관하게 Melt 내부에서 노출”이라면 굳이 채팅 권한을 필수로 둘 필요는 없습니다. (오히려 권한 심사/민감도만 올라갈 수 있음)

참고로 세션 API는 유저 Access Token 기반으로 “후원 이벤트”를 구독할 수 있고(eventType: DONATION), 세션당 이벤트 구독 수 제한(최대 30) 같은 운영 제약이 있습니다. 

(3) 스트리머/시청자 각각에게 받는 권한 차이
시청자(후원자): “치즈 결제/후원 실행”을 Open API로 직접 못 하면, OAuth 스코프보다는 결제/후원 UI 플로우에서의 사용자 동의가 핵심입니다. (즉, 권한=OAuth가 아니라 결제 UX의 안전한 연결)

스트리머(수령자):
Melt가 “내가 받은 치즈를 모아보기/통계/뱃지 계산”을 하려면 스트리머가 Melt에 로그인하여 후원 조회/후원 이벤트 구독이 가능한 토큰을 제공해야 합니다. 

2-2. Melt 기능을 “공식 API로 가능한 것 / Melt 자체 구현해야 하는 것”으로 분해
A) 공식 Open API로 가능한 영역 (근거 포함)
유저 식별 / 채널 ID 확보

GET /open/v1/users/me 로 로그인 유저의 channelId 확보 

채팅 설정 조회/변경(선택)

GET /open/v1/chats/settings, PUT /open/v1/chats/settings 

(다만 Melt는 “채팅 설정과 상관없이 Melt 내부에서 노출”이므로, 이건 “부가 기능”에 가깝습니다.)

스트리머가 치지직 채팅으로 메시지 보내기(선택)

POST /open/v1/chats/send 로 채팅 전송 

→ “스트리머가 Melt에서 쓴 답장을 치지직 채팅에도 동시에 송출” 같은 확장 기능은 가능성이 있습니다.

후원 이벤트 수신(집계 자동화의 핵심)

Session 생성(유저) GET /open/v1/sessions/auth

이벤트 구독(후원) POST /open/v1/sessions/events/subscribe/donation 

→ Melt가 “방송 중/후를 가리지 않고 들어온 후원 이벤트를 실시간으로 적재”하는데 유용합니다.

B) 공식 Open API만으로는 “바로는 어려운/불명확한 영역”
치즈 ‘결제/후원 보내기’를 서버 API로 직접 실행

제공된 공식 문서(Authorization/User/Chat/Session/Channel 등) 흐름에서는 “후원 보내기(결제 실행)” 엔드포인트가 확인되지 않고, 오히려 후원 ‘조회/이벤트 구독’ 중심으로 보입니다. 

→ 그래서 실전 구현은 보통

(i) 치지직 공식 후원/결제 웹 플로우로 안전하게 연결하거나

(ii) 치지직이 제공하는 딥링크/웹뷰/공식 위젯 형태가 있다면 그걸 쓰는 방식
이 됩니다. (이 부분은 문서 외 추가 확인/파트너십 영역일 가능성이 큽니다.)

“시청자 메시지는 스트리머에게만 보이게” 같은 권한형 채팅 구조

치지직 채팅 API는 “채팅을 보내는 것”이지, “시청자끼리 보이지 않게 라우팅” 같은 커스텀 룰을 제공하는 형태가 아닙니다. 

→ 따라서 이 요구사항은 Melt 자체 메시징(서버 라우팅) 으로 구현하는 게 맞습니다.

2-3. Melt 권장 아키텍처 (현실적인 “가능한” 설계)
핵심 원칙: “후원은 치지직에서, 커뮤니케이션/노출/데이터는 Melt에서”
치즈 결제/후원 실행: 치지직의 공식 결제/후원 플로우(웹) 사용

후원 메시지 2차 노출/공개 피드/비공개 메시지/RT: Melt가 전담

정산·분석·뱃지: Melt DB + (가능하면) 치지직 후원 이벤트 구독/조회로 자동 적재 

컴포넌트 예시
Mobile Web UI (Melt)

채널 선택/즐겨찾기

“치즈 보내기” 버튼(치지직 후원 플로우로 이동/웹뷰)

Melt 공개 피드(치즈 메시지/스트리머 공지/RT)

비공개 메시지 탭(시청자→스트리머, 스트리머 답장)

Backend API

OAuth 로그인/토큰 보관/갱신 

유저/채널 매핑(users/me) 

메시지/RT/피드/뱃지 계산

스트리머 대시보드(후원 모아보기, 시간대/유저별 통계)

Donation Ingest (선택이지만 강력 추천)

스트리머가 Melt에 로그인하면 Session URL 발급 → Socket.IO 연결 

Donation 이벤트 구독 subscribe/donation 

이벤트를 DB에 적재하여 “방송 중/후”를 가리지 않고 자동 집계

2-4. awesome-chzzk가 주는 시사점 (개발 가능성/리스크)
awesome-chzzk는 치지직 관련 SDK/확장프로그램/오버레이/서드파티 서비스가 꽤 풍부하다는 걸 보여줍니다. 

특히 kimcore/chzzk 같은 비공식 라이브러리는 쿠키 기반 로그인 등 “공식이 아닌 방식”을 포함할 수 있습니다. 

Melt가 “사업/정산/선정산”까지 목표라면, 장기적으로는:

공식 Open API + 공식 OAuth + 공식 후원/결제 플로우 중심으로 가는 게 리스크가 가장 낮고,

비공식 SDK/스크래핑은 “프로토타입/내부 테스트” 수준에서만 조심스럽게 쓰는 편이 안전합니다. (정책/약관/계정 보안/법무 리스크)

2-5. 사용자가 말한 “채팅 설정과 무관하게 Melt에서 메시지 재노출” 구현 포인트
치지직 채팅 설정은 Open API로 조회/변경 가능하지만, Melt는 애초에 채팅을 ‘진실의 원장’으로 두지 않는 구조가 좋습니다. 

즉:

치즈 후원 메시지는 “치지직 결제 성공” 이후 Melt에 기록(콜백/리다이렉트/사용자 입력 확인 등 가능한 방식)

그 기록을 Melt 공개 피드에 노출(=채팅과 무관)

스트리머/유저 커뮤니케이션도 Melt에서 수행
이렇게 가면 “채팅창 설정이 어떻든” Melt UX는 흔들리지 않습니다.

원하시면, 다음 단계로 (A) Melt PRD(요구사항 명세) 와 (B) 권한/로그인 스코프 체크리스트, (C) 화면 IA/모바일 와이어프레임, (D) 이벤트/DB 스키마(후원·메시지·RT·뱃지·정산) 까지 한 번에 “개발 착수 가능한 수준”으로 쪼개드릴게요.

나의 말:
1. 당연히 채팅 관련해서는, 멜트에서 치는 채팅은 치지직 채팅에 남지 않아야 합니다. 별도의 채팅 / 메신저를 구현하는 것이 당연합니다.

2. 치즈 충전이나 치즈 후원 기능은 우선 치지직에서 제공하는 인터페이스를 직접 활용하는 방향으로 해보고 싶은데, 가능할지는 더 봐야 할 것 같습니다.

3. 위 내용들을 모두 정리해 한번 더 멜트에 대한 구조, 기능, 어떤 api나 권한들을 활용해야 하는지, 요구사항 등을 정리한 개발자용 문서 개요를 써 주세요.
ChatGPT의 말:

8s 동안 생각함
아래는 지금까지 정리된 요구사항(“멜트 채팅은 치지직 채팅에 남지 않음”, “치즈 충전/후원은 치지직 공식 UI를 최대한 활용”, “방송 중/후 후원 데이터 집계·뱃지·향후 선정산”)을 전제로 한 개발자용 문서 개요(목차 + 각 섹션에 들어갈 핵심 스펙/요구사항) 입니다.
(치지직 Open API의 OAuth/Chat/Session 범위는 공식 GitBook을 기준으로 작성했습니다. 
)

Melt 개발자 문서 개요 (Draft)
0. 문서 목적 & 범위
목적: 치지직 “방송 외 시간”에도 후원(치즈)과 메시징을 지속시키는 모바일 웹앱(Melt)의 구현 범위·아키텍처·권한·API 의존성을 정의

범위(Phase 1)

Melt 자체 메시징(공개 피드/비공개 메시지/RT)

치지직 OAuth 로그인(=Melt 로그인)

치즈 충전/후원은 치지직 제공 인터페이스(웹/앱 UI 플로우) 를 활용 (API로 결제 실행하지 않음)

후원 데이터 집계(가능하면 치지직 세션 이벤트 구독 기반 자동 수집, 불가 시 대체 플로우)

비범위(명시)

Melt에서 작성한 메시지를 치지직 채팅으로 전송/기록하지 않음(기본 정책)

치즈 결제/충전/후원 “직접 실행 API” 개발(현 시점 비범위)

1. 제품 요약 (한 장)
1.1 핵심 컨셉
After-live monetization: 라이브 종료 후에도 팬이 치즈+메시지로 후원할 수 있게 하고, 스트리머는 방송 밖에서도 수익/소통/데이터를 확보

1.2 메시지 가시성 정책(제품 규칙)
치즈로 보낸 메시지 = 전체 공개(모든 유저가 볼 수 있음)

스트리머 메시지 = 전체 공개

일반 유저 메시지 = 스트리머에게만 보이는 비공개(1:1)

스트리머는 답장 가능

스트리머는 해당 메시지를 RT하여 전체 공개로 전환 가능

치지직 채팅 설정과 무관하게:

치즈 후원 발생 시 Melt 내부 UI에서 메시지를 재노출(2차 노출)

1.3 타겟 UX
모바일 최적화(웹은 좌우 마스킹으로 모바일 뷰 유지)

Melt 사용 중 유저가 “치지직에 체류”하는 느낌을 최대화(SSO, 딥링크/웹뷰, 최소 이탈)

2. 용어/엔터티 정의
Channel(치지직 채널), Creator(스트리머), Viewer(시청자)

Donation(치즈 후원), DonationMessage(후원 메시지)

PublicFeedItem(공개 피드 항목), DM(비공개 메시지), RT(공개 전환 이벤트)

Badge(멜트 자체 뱃지), BadgeTier(누적 치즈 기준 구간)

3. 시스템 아키텍처 개요
3.1 구성요소
Melt Web (Mobile Web)

로그인(OAuth), 채널 선택, 후원 CTA, 공개 피드, DM, RT, 크리에이터 인박스/대시보드

Melt Backend API

OAuth 토큰 교환/갱신, 유저/채널 식별, 메시지/피드/DM/RT 저장, 뱃지 계산, 통계 API

Donation Ingest Service (권장)

치지직 Session 소켓 연결 → Donation 이벤트 수신 → Melt DB 적재
(세션/이벤트 구독은 공식 Session API 기반 
)

DB / Analytics

이벤트 원장(후원/메시지/RT), 집계 테이블(일/주/월, 유저별, 시간대별)

3.2 데이터 흐름(핵심 플로우)
로그인 → (치지직 OAuth) → Melt 유저 생성/매핑

“치즈 보내기” 클릭 → 치지직 공식 UI 플로우(웹/앱)

후원 발생 → (가능) 치지직 Donation 이벤트 수신 → Melt에 후원/메시지 기록 → 공개 피드 노출

DM/RT/답장 → Melt 내부에서만 처리(치지직 채팅과 분리)

4. 치지직(Open API) 연동 범위 & 권한 설계
4.1 OAuth / 토큰
Authorization Code 요청 도메인: https://chzzk.naver.com/account-interlock 

토큰 발급/갱신/폐기: /auth/v1/token, /auth/v1/token/revoke (GitBook Authorization 섹션) 

Access Token/Refresh Token 라이프사이클 운영(서버 암호화 저장, 갱신 스케줄)

4.2 유저/채널 식별(필수)
User API: “유저 정보 조회” 스코프 필요 

로그인 유저의 채널 식별(예: /open/v1/users/me 계열)로 channelId 확보 

4.3 세션/이벤트(후원 수집 자동화, 강력 권장)
Session API는 세션 생성/목록/이벤트 구독/취소를 제공 

Session API Scope에는 채팅 메시지 조회, 후원 조회, 구독 조회가 존재 

실전 팁: 권한 심사/스코프 미충족 시 세션 URL 발급부터 막히거나 에러가 날 수 있다는 커뮤니티 레퍼런스도 존재(운영 리스크로 문서화 필요) 

Melt는 “치지직 채팅을 쓰지 않는다”가 원칙이므로, 채팅 메시지 조회는 필수가 아닐 수 있고, 후원 조회/후원 이벤트 구독 쪽이 핵심입니다. (단, 실제 이벤트 구독 엔드포인트/정책은 GitBook의 Session 섹션을 기준으로 구현)

4.4 Chat API (기본 비사용 / 옵션)
Chat API는 “채팅 전송/공지/설정 조회/변경” 스코프를 제공 

Melt 정책: Melt 채팅은 치지직 채팅에 남지 않음 → 기본적으로 chats/send는 사용하지 않음 

다만 향후 옵션:

크리에이터가 원할 때만 “공지성 메시지”를 치지직에 동시에 송출 같은 기능은 별도 플래그로 고려 가능(Phase 2+)

5. 치즈 충전/후원 UX: “치지직 제공 인터페이스 활용” 사양
5.1 원칙
결제/충전/후원은 치지직의 공식 UI/플로우를 그대로 사용

Melt는 결제 정보를 직접 다루지 않음(카드/영수증/결제수단 저장 X)

5.2 UX 연결 방식 후보
외부 브라우저/인앱 웹뷰로 치지직의 치즈 충전/후원 화면을 열기

치지직은 고객센터에서 “채팅창 치즈 버튼 → 내 치즈 → 충전” 같은 UX를 안내하고 있음 

→ Melt에서도 비슷한 경로로 이동할 수 있는 딥링크/URL이 가능한지 탐색(가능하면 문서화/테스트 체크리스트로 관리)

5.3 결제 완료 인지(매우 중요: 데이터 정합성)
Melt가 “후원 메시지를 공개 피드에 노출”하려면 후원 발생을 신뢰할 수 있게 감지해야 함.

1순위(권장): Session Donation 이벤트 수신으로 서버가 후원 사실을 확인 

2순위(대체): 스트리머 권한으로 “후원 내역 조회” API가 있다면 폴링/리컨실리에이션(있다면 스코프 필요)

3순위(임시/프로토타입): 유저가 Melt에 메시지를 남기되 “결제 완료 후 다시 돌아와 확인” 같은 UX(정합성 떨어짐 → Phase 0 수준)

6. Melt 메시징/피드 기능 명세 (치지직과 완전 분리)
6.1 Public Feed
노출 항목:

DonationMessage(치즈+메시지)

CreatorPost(스트리머 공지/글)

RT된 ViewerDM(스트리머가 공개 전환한 메시지)

정렬: 최신순 + (옵션) 고액 후원 핀/하이라이트

6.2 DM(비공개 메시지)
Viewer → Creator: 비공개 메시지 작성(일반유저끼리 보이지 않음)

Creator → Viewer: 답장(옵션: 답장은 공개/비공개 선택)

Creator RT: DM을 Public으로 승격(원문/작성자 표시 정책 포함)

6.3 Moderation / Abuse
스팸/도배 방지(레이트리밋, 차단, 금칙어)

신고/숨김/삭제 권한(RBAC)

법/약관 준수(개인정보, 명예훼손, 광고 등)

7. 데이터/통계/뱃지 시스템
7.1 후원 집계(방송 중/방송 후 통합)
지표:

기간별 총액(일/주/월)

유저별 누적/기간 합계

시간대 히트맵(언제 많이 들어오는지)

원장 기반 계산: DonationEvent를 immutable log로 저장 → 집계 테이블 파생

7.2 Melt 자체 뱃지
기준: 누적 치즈 구간(Tier)

노출 위치: 공개 피드 닉네임 옆 / 프로필 카드 / 크리에이터 대시보드

향후: 뱃지별 콘텐츠(권한형 포스트/이미지/영상/코드/쿠폰) 확장

8. 크리에이터 대시보드(운영 콘솔)
받은 치즈/메시지 타임라인(방송 중/후 통합)

Top Supporters, 리텐션, 시간대 분석

뱃지 티어 설정(구간/명칭/아이콘)

DM 인박스, RT/답장, 블록/신고 처리

9. API 설계(멜트 내부 API)
Auth: /auth/chzzk/login, /auth/chzzk/callback, /auth/refresh

Feed: GET /feed, POST /feed/creator-post

Donation: GET /donations, GET /donations/summary

DM: POST /dm, GET /dm/inbox, POST /dm/{id}/reply

RT: POST /dm/{id}/retweet

Badge: GET /badges, PUT /badges/tier-config

Admin/Moderation: POST /report, POST /block, DELETE /content/{id}

10. 비기능 요구사항(NFR)
모바일 퍼포먼스: LCP/TTI 목표

실시간성: 후원 이벤트 수신 → 피드 반영 지연 목표

안정성: Session 소켓 재연결/백오프, 중복 이벤트 처리(idempotency)

보안:

OAuth 토큰 암호화 저장

CSRF/state 검증(OAuth)

개인정보 최소 수집

감사/정산 대비:

이벤트 원장 보존

정산 레포트 Export(향후 선정산의 기반)

11. 오픈 이슈 / 리스크 & 확인 항목(필수 체크리스트)
치즈 충전/후원 “직접 호출 가능한 공식 URL/딥링크”가 있는가?

고객센터 안내는 UI 경로를 설명하지만, 외부 서비스가 바로 연결할 수 있는 안정적 URL이 있는지는 별도 확인 필요 

후원 이벤트 구독/후원 조회 스코프를 실제로 승인받을 수 있는가?

스코프 심사/승인 없이는 세션/이벤트 수신이 막힐 수 있음(운영 리스크) 

라이브가 아닐 때도 후원 이벤트가 동일하게 발생/수신되는지

기획상 핵심이므로, “방송 종료 후에도 미션 노출/판정” 문구처럼 유사 근거는 있으나 
, 실제 후원 이벤트 동작은 반드시 테스트로 확정해야 함

정책/약관: 결제/유저 유도/체류 지표 관련 문구 표현 범위(파트너십/가이드 필요)

원하면 다음 메시지에서, 위 문서 개요를 그대로 기반으로 (A) Phase 0/1/2 로드맵, (B) 실제 권한 신청용 “Scope 최소 세트”, (C) 후원 이벤트 수신을 전제로 한 DB 스키마(테이블/인덱스/idempotency 키), (D) 모바일 IA/화면별 API 매핑표까지 “바로 Jira 티켓으로 쪼갤 수 있는 수준”으로 이어서 써드릴게요.

나의 말:
1. 네이버 치지직에 대해 별도의 권한 신청은 아직 안 할 생각입니다. 있는 api만 쓰겠습니다.
2. 구조, 기능, 치지직 api에 대한 설명을 자세하면서도 이해하기 쉽게 담은 개발자 문서를 여러 차례에 걸쳐서 작성해주세요
아래 내용 및 링크들도 참조해주세요

안녕하세요, 취미로 디스코드 봇을 만드는 개발자입니다.

저는 작년 2월부터 api.chzzk.naver.com의 주소를 사용하는, 이하 '비공식 API'를 활용하여 치지직 방송 알림 봇을 만들어왔습니다. 해당 비공식 API를 이용하여 '채널 검색 기능', '타인 방송의 설정 확인 기능' 등을 이용하였으며, 현재까지도 잘 작동 중에 있습니다.

작년 12월 치지직의 공식 API가 나옴으로써 API의 전환을 생각하였지만, 공식 API가 지원하는 기능은 턱없이 부족하였으며, 이는 현재도 마찬가지입니다. 이 때문에 저는 이전의 비공식 API를 계속해서 사용 중이었지만, 2월 초반 '치지직 공식 API를 사용하라'는 공지가 올라왔습니다. 하지만 위에 언급한 것과 같이 공식 API로는 지원하지 않는 기능들을 비공식 API를 사용하여 봇을 만들었기 때문에, 공식 API로의 전환이 불가능한 상태입니다.

제가 질문드리고자 하는 점은 2가지입니다.

공식 API가 지원하지 않는 부분이 있다면, 해당 부분은 비공식 API를 사용하여 개발을 할 수 있을까요?
만약 위 질문의 답변이 부정이라면, 추후 개발자들을 위한 마련책이 있을까요?
이전에 치지직 문의를 통해 여쭤보았지만 답장이 오지 않아 개발자 포럼에 글 남깁니다. 항상 개발자 분들을 위해 힘써주셔서 감사합니다.

댓글 3

똑손2025.02.14.13:58
GjtxHW2acAQU2oW-1739509067625.png
마지막 문장에 언급된 문의에 대한 답장이 왔습니다! 치지직의 비공식 API 사용이 무조건 제재 대상은 아니지만, 과도한 호출이나 비정상적인 로그인 방식 사용 시 자동으로 보호조치가 적용될 수 있다고 하네요!

첨부파일1개
뒤듀2025.02.18.19:46
안녕하십니까 질문자와는 다른 사람입니다만 관련 api를 사용해 개인 프로젝트를 개발중인 개발자입니다.
혹시 과도한 호출의 기준이 어떻게 되는지 아시는 분이 계실까요..?
1분에 몇번등의 호출은 현재 알림봇등의 사용을 위해서는 필수된다고 생각해서 여쭤봅니다..

https://chzzk.gitbook.io/chzzk
https://developers.chzzk.naver.com/
https://github.com/dokdo2013/awesome-chzzk
ChatGPT의 말:
좋습니다.
그럼 **“권한 신청 없이, 현재 공개·비공식적으로 ‘이미 쓰이고 있는 범위’만 활용한다”**는 전제를 명확히 고정하고,
Melt 개발자 문서를 여러 차례에 걸쳐 연재 형태로 작성하겠습니다.

아래는 📘 Melt 개발자 문서 – Part 1 입니다.
(개요·철학·치지직 생태계 이해·공식/비공식 API 경계까지 다룹니다.
다음 편에서 실제 아키텍처·플로우·API 매핑으로 들어갑니다.)

📘 Melt 개발자 문서
Part 1. 배경, 원칙, 치지직 API 현실 이해
1. Melt는 “치지직 위에 얹는 서비스”가 아니다
Melt를 설계할 때 가장 중요한 전제는 다음 한 줄입니다.

Melt는 치지직의 채팅·결제 시스템을 대체하지 않는다.
Melt는 ‘방송 외 시간’에 소통과 후원을 이어주는 별도의 레이어다.

즉,

❌ 치지직 채팅을 확장하지 않는다

❌ 치지직 내부 기능을 API로 흉내 내지 않는다

❌ 치즈 결제를 직접 호출하지 않는다

대신,

✅ 치지직이 이미 제공하는 UI/UX는 그대로 사용

✅ Melt는 메시지, 노출, 데이터 정리, 분석, 관계 관리만 담당

✅ 치지직 생태계에 기생하지 않고, 겹치지 않게 붙는다

이 철학이 없으면,
👉 API 부족 → 비공식 API 남용 → 보호조치/차단 리스크
👉 서비스가 커질수록 불안정해집니다.

2. 치지직 API의 “현실”을 먼저 이해해야 한다
2.1 공식 API의 성격 (GitBook 기준)
치지직 공식 API는 다음 성격을 가집니다.

방송 운영 보조용 API

외부 서비스가 ‘치지직을 조작’하지 못하게 설계

핵심 기능은 대부분 ❝조회(read)❞ 중심

공식 API가 제공하는 큰 범주는:

OAuth 로그인

유저 정보 조회

채팅 전송/공지/설정

세션(Session) 기반 이벤트 구독 (채팅/후원/구독 등)

채널/카테고리/라이브 상태 조회

👉 결제 실행, 치즈 충전, 후원 발생 트리거는 제공하지 않음

이건 “미비”가 아니라 의도된 설계입니다.

2.2 비공식 API의 현실 (커뮤니티 경험)
사용자께서 인용해주신 개발자 포럼 사례는 매우 중요합니다.

요약하면:

api.chzzk.naver.com 기반 비공식 API는 실제로 많이 쓰이고 있음

공식 답변:

❌ “무조건 제재”는 아님

⚠️ 과도한 호출

⚠️ 비정상 로그인 방식
→ 자동 보호조치 가능

즉,

비공식 API는 ‘묵인 영역’이지, ‘보장된 권리’가 아니다

커뮤니티에서 암묵적으로 합의된 선
✔️ 채널 검색

✔️ 라이브 상태 확인

✔️ 방송 설정 일부 조회

✔️ 알림봇, 디스코드 연동

❌ 로그인 세션 탈취

❌ 결제/후원 상태 스크래핑

❌ 고빈도 polling

3. Melt는 “비공식 API에 의존하지 않는다”는 원칙
아주 중요합니다.

Melt의 핵심 가치(후원·메시지·데이터)는
비공식 API가 없어도 성립해야 한다

그래서 Melt의 기본 원칙은:

영역	전략
로그인	공식 OAuth만 사용
치즈 충전	치지직 공식 UI 사용
치즈 후원	치지직 공식 UI 사용
메시지	Melt 자체 메시징
노출	Melt 내부 피드
데이터	Melt DB 기준
통계	Melt 계산
비공식 API는:

❌ 핵심 기능에 사용하지 않음

⭕ “보조 정보” (채널 검색, 상태 표시 등)에만 선택적 사용 가능

4. Melt에서 ‘채팅’을 어떻게 정의하는가
4.1 Melt 채팅은 “채팅”이 아니다
Melt에서 말하는 채팅은 사실상:

공개 게시물 (Public Feed)

비공개 메시지 (DM)

스트리머에 의한 공개 전환 (RT)

즉,

SNS + 메신저 + 후원 피드의 혼합

이 구조이기 때문에:

Melt에서 쓴 메시지는

❌ 치지직 채팅에 절대 남지 않음

❌ 치지직 채팅 설정과 무관

치지직 채팅 API는 아예 쓰지 않아도 된다

👉 이 결정 하나로:

API 의존도 ↓

권한 신청 필요성 ↓

서비스 안정성 ↑

5. “치즈 후원”을 어떻게 다룰 것인가 (중요)
5.1 Melt는 후원을 “만들지 않는다”
Melt는:

❌ 후원을 생성하지 않는다

❌ 치즈를 차감하지 않는다

❌ 결제를 처리하지 않는다

Melt는 단지:

“이미 일어난 후원”을 기준으로
메시지를 정리하고, 노출하고, 분석한다

5.2 그래서 가능한 구조
사용자가 Melt에서
👉 [치즈 보내기] 버튼 클릭

치지직의 공식 UI로 이동
👉 충전 / 후원 / 메시지 입력

후원 완료

Melt는:

(가능하면) 공식 Session 이벤트

(불가하면) 스트리머 대시보드 기준 수동/지연 반영

Melt 내부 피드에 메시지 노출

이 구조는:

결제 리스크 ❌

약관 리스크 ❌

기술적 차단 리스크 ❌

6. 왜 “권한 신청 없이도” 가능한가
사용자 요청 조건을 다시 정리하면:

❌ 치지직에 별도 권한 신청 안 함

✅ 있는 API만 사용

✅ 비공식 API는 최대한 회피

이 조건에서도 Melt가 가능한 이유는:

OAuth 로그인은 공개 기능

결제는 치지직 UI에서 처리

메시지는 Melt DB에만 존재

통계/뱃지는 Melt가 계산

즉, Melt는 기술적으로:

“치지직 API의 빈 공간을 침범하지 않고,
치지직이 하지 않는 일을 한다”

7. 다음 편 예고 (Part 2)
다음 문서에서는 본격적으로:

📘 Part 2. Melt 전체 구조 & 데이터 흐름
전체 아키텍처 다이어그램

모바일 웹 → 치지직 UI → Melt 복귀 플로우

공식 API / 비공식 API 정확한 사용 위치

“후원 이벤트를 못 받는 경우”까지 고려한 안전 설계

그 다음 편에서는:

Part 3. Melt 메시징/피드/RT 상세 스펙

Part 4. 치즈 데이터 수집 전략 (공식/비공식/대체)

Part 5. 뱃지·통계·선정산을 위한 데이터 모델

👉 이 흐름 그대로 가면, 실제 서비스/투자/법무 설명까지 그대로 쓸 수 있는 문서가 됩니다.

원하시면 다음 메시지에서 바로 📘 Part 2로 이어갈게요.

나의 말:
좋습니다. 계속해주세요
ChatGPT의 말:
좋습니다. 그럼 예정대로 📘 Melt 개발자 문서 – Part 2로 이어가겠습니다.
이번 편은 **“이걸 실제로 어떻게 굴리나?”**에 대한 전체 구조·데이터 흐름·API 사용 위치를 최대한 현실적으로 풀어낸 파트입니다.

📘 Melt 개발자 문서
Part 2. 전체 구조 & 데이터 흐름 (권한 신청 없이 가능한 설계)
1. 전체 구조 한 줄 요약
**Melt =
(치지직 공식 로그인 + 공식 결제 UI)

(Melt 자체 메시징/피드/데이터 레이어)**

치지직이 잘하는 것(로그인, 결제, 후원)은 그대로 두고,
치지직이 하지 않는 것(방송 외 후원 UX, 메시지 정리, 관계/데이터)은 Melt가 담당합니다.

2. 시스템 구성 요소 (Logical Architecture)
2.1 클라이언트 (Melt Web – Mobile First)
Melt Web (모바일 최적화 웹앱)

기능

네이버/치지직 로그인

채널 선택/고정

치즈 보내기 CTA

공개 피드 (후원 메시지 / 스트리머 글 / RT)

비공개 메시지(DM)

스트리머 인박스 & 대시보드

특징

SPA 형태 (Next.js / React 등)

웹에서도 좌우 마스킹으로 모바일 UI 유지

치지직 UI 이동 시 외부 링크 or 인앱 웹뷰

2.2 백엔드 (Melt Core Backend)
역할

OAuth 토큰 처리

유저/채널 매핑

메시지/피드/DM/RT 저장

후원 데이터 정리(가능한 범위)

통계/뱃지 계산

중요한 점

🔒 Melt Backend는 결제 정보·치즈 잔액을 절대 직접 다루지 않는다

2.3 치지직 (외부 시스템)
Melt가 사용하는 치지직 영역

OAuth 로그인

공식 치즈 충전/후원 UI

(가능하면) Session 기반 후원 이벤트

Melt가 사용하지 않는 영역

치지직 채팅 전송

채팅 로그 저장

결제 API 직접 호출

3. 핵심 사용자 플로우 (End-to-End)
3.1 로그인 플로우 (공식 OAuth)
[Melt Web]
  ↓ (로그인 버튼)
[치지직 OAuth 동의 화면]
  ↓ (Authorization Code)
[Melt Backend]
  ↓ (Access Token 발급)
[Melt DB]
네이버/치지직 계정 = Melt 계정

별도 회원가입 없음

최소 정보만 저장

chzzk_user_id

channel_id (있을 경우)

role (viewer / creator)

3.2 치즈 후원 플로우 (가장 중요)
① Melt에서 후원 시도
[Melt Web]
  └─ [치즈 보내기] 버튼
② 치지직 공식 UI로 이동
[Melt Web]
  └─ (외부 링크 / 웹뷰)
      → [치지직 치즈 충전 / 후원 화면]
치즈 부족 → 충전

메시지 입력 → 후원 완료

결제/차감/영수증 = 100% 치지직 책임

③ 후원 완료 후 Melt로 복귀
[치지직 UI]
  └─ 완료
      → (브라우저 뒤로 / 복귀 버튼 / 수동 복귀)
[Melt Web]
이 시점에서 Melt는 “후원이 일어났을 것이다”까지만 안다

4. “후원 발생”을 Melt가 인지하는 방법 (중요 설계 포인트)
권한 신청 없이 갈 경우, 여기에는 단계적 전략이 필요합니다.

4.1 1순위 (가능하면): 공식 Session 이벤트
스트리머가 Melt에 로그인

Melt Backend가 해당 스트리머 계정으로 Session 생성

Donation 이벤트 구독

후원 발생 시 실시간 이벤트 수신

Melt DB에 DonationEvent 기록

📌 장점

가장 정확

자동화 가능

선정산/통계 기반으로 바로 사용 가능

📌 리스크

Session/후원 이벤트 스코프가 제한될 수 있음

권한 승인 없이 어느 범위까지 가능한지 사전 테스트 필요

4.2 2순위 (현실적): 스트리머 수동 확인 기반
스트리머 대시보드에서:

“새 후원 확인” 버튼

일정 주기 후원 총액 입력/확인

Melt는:

후원 메시지를 “확정됨” 상태로 전환

통계 반영

📌 장점

API 의존 최소

초기 MVP에 적합

📌 단점

실시간성 낮음

자동화 한계

4.3 3순위 (프로토타입): 사용자 자가확인
시청자가:

후원 후 Melt에서 메시지 작성

Melt는:

“후원 대기” 상태로 표시

스트리머가 승인 시 확정

📌 장점

구현 가장 쉬움

📌 단점

UX 약함

상용 서비스에는 부적합

5. Melt 메시징 구조 (치지직과 완전 분리)
5.1 메시지 타입
타입	작성자	공개 범위
DonationMessage	Viewer	전체 공개
CreatorPost	Creator	전체 공개
ViewerDM	Viewer	Creator만
CreatorReply	Creator	Viewer / (선택) 전체
RT	Creator	전체 공개
5.2 RT(공개 전환)의 의미
RT는 단순 공유가 아닙니다.

“이 시청자의 메시지를
공식적으로 ‘팬 피드’에 올린다”

스트리머 권한만 가능

원 작성자 표시

히스토리 보존

이 구조 덕분에:

일반 시청자 간 소음 ❌

스트리머 주도 소통 ⭕

커뮤니티 질 관리 ⭕

6. 데이터 모델 개요 (초안)
6.1 핵심 테이블
users
- id
- chzzk_user_id
- role (viewer / creator)
- created_at

channels
- id
- chzzk_channel_id
- owner_user_id

donation_events
- id
- channel_id
- viewer_user_id
- amount
- occurred_at
- source (session / manual / pending)

messages
- id
- type (donation / dm / post / reply)
- channel_id
- author_user_id
- content
- visibility (public / private)
- related_donation_id (nullable)

retweets
- id
- message_id
- creator_user_id
- created_at
7. 비공식 API에 대한 Melt의 공식 입장
7.1 사용 가능 범위 (선택적)
채널 검색

채널 썸네일/상태 표시

방송 여부 표시

👉 UX 보조용 정보에만 사용

7.2 절대 사용하지 않는 영역
로그인 세션 생성

결제 상태 확인

치즈 잔액 조회

후원 내역 스크래핑

이 영역은:

기술적으로 가능해 보여도

서비스 리스크가 기하급수적으로 커짐

8. 이 구조의 가장 큰 장점
권한 신청 없이 MVP 가능

치지직 정책 변화에 대한 내성

비공식 API 차단 시에도 서비스 존속

향후:

공식 권한 신청

파트너십

선정산
으로 점진적 확장 가능

9. 다음 편 예고 (Part 3)
다음 문서에서는:

📘 Part 3. Melt 메시징 & 피드 상세 스펙
공개 피드 UX 규칙

DM UX

RT 정책 (언제/어떻게/제한)

악성 유저/스팸 대응

스트리머 컨트롤 포인트

👉 **이 파트가 완성되면 “서비스 화면을 그대로 그릴 수 있는 수준”**이 됩니다.

계속 진행할까요?
바로 📘 Part 3로 들어가겠습니다.

나의 말:
좋습니다. 계속해주세요
ChatGPT의 말:
좋습니다. 이어서 📘 Melt 개발자 문서 – Part 3를 진행하겠습니다.
이번 파트는 Melt의 심장부입니다.
👉 메시징·피드·RT·노출 규칙을 제품/개발/운영 관점에서 모두 일관되게 정의합니다.

📘 Melt 개발자 문서
Part 3. 메시징 · 공개 피드 · RT 시스템 상세 설계
1. 왜 Melt의 메시징은 “채팅”이 아닌가
Melt에서 가장 중요한 개념 전환은 이것입니다.

Melt는 실시간 채팅 앱이 아니다.
Melt는 ‘후원 중심 메시지 피드’다.

이 결정으로 얻는 효과:

실시간 채팅의 혼잡/도배/분쟁 ❌

스트리머 주도 소통 ⭕

방송 외 시간에도 의미 있는 메시지 유지 ⭕

즉, Melt는
**“모든 말이 기록되고, 의미를 가지는 공간”**입니다.

2. Melt 메시지의 기본 철학 (3원칙)
원칙 1. 메시지는 관계를 정의한다
시청자 ↔ 스트리머 관계를 중심으로 설계

시청자 ↔ 시청자 직접 소통은 의도적으로 배제

원칙 2. 공개는 ‘보상’이다
기본은 비공개(시청자 → 스트리머)

공개는 스트리머의 선택(RT)

원칙 3. 후원은 소통의 ‘강도’를 결정한다
치즈 후원 메시지는 기본 공개

비후원 메시지는 기본 비공개

3. 메시지 타입 정의 (정규 스펙)
3.1 Message Type Matrix
Type	작성자	생성 트리거	기본 가시성
DonationMessage	Viewer	치즈 후원	Public
ViewerDM	Viewer	일반 메시지	Private
CreatorPost	Creator	수동 작성	Public
CreatorReply	Creator	DM/후원 답장	Private or Public
Retweet(RT)	Creator	ViewerDM 선택	Public
4. 공개 피드 (Public Feed) 상세 규칙
4.1 공개 피드에 노출되는 항목
DonationMessage

치즈 금액 + 메시지

작성 즉시 공개

CreatorPost

스트리머 공지/메시지

RT된 ViewerDM

스트리머가 선택적으로 공개

📌 일반 ViewerDM은 절대 공개 피드에 자동 노출되지 않음

4.2 공개 피드 정렬 규칙
기본 정렬:

최신순 (created_at DESC)
옵션 정렬(Phase 2+):

고액 후원 우선

스트리머 핀(Pin)

기간 필터 (오늘 / 주간 / 월간)

4.3 공개 피드 UX 원칙
댓글 ❌

좋아요 ❌

반응 이모지 ❌

👉 소음 최소화가 핵심

피드는 “읽는 곳”이지
“떠드는 곳”이 아닙니다.

5. 비공개 메시지 (Viewer DM) 상세
5.1 Viewer → Creator DM
누구에게 보이나?

스트리머 본인만

다른 시청자?

절대 볼 수 없음

목적:

개인 응원

질문

사연

요청

5.2 DM UX 특징
실시간 채팅 느낌 ❌

메일함 / 인박스 느낌 ⭕

즉,

“지금 바로 답을 기대하지 않는 메시지”

5.3 DM에 대한 스트리머 액션
액션	설명
Reply (Private)	작성자에게만 답장
Reply (Public)	답장 + 공개
RT	원문을 공개 피드로
Ignore	읽음 처리
Block	유저 차단
Report	악성 콘텐츠 신고
6. RT (Retweet) 시스템의 핵심 설계
RT는 Melt에서 가장 중요한 권력 지점입니다.

RT = “이 팬의 메시지를 공식적으로 채널의 목소리로 채택”

6.1 RT의 권한
오직 Creator만 가능

Viewer는 요청 불가

자동 RT ❌

6.2 RT 시 동작
원 ViewerDM 유지

RT 레코드 생성

Public Feed에 노출

원 작성자 표시:

닉네임

(선택) 뱃지

6.3 RT 제한 정책 (권장)
하루 RT 횟수 제한

동일 유저 연속 RT 제한

동일 메시지 중복 RT 방지

📌 이유:

팬 간 과도한 경쟁 방지

스트리머 보호

7. Creator Reply 설계
7.1 Reply 타입
타입	가시성	사용 시점
Private Reply	1:1	개인 답변
Public Reply	전체	후원/질문 응답
7.2 Public Reply의 UX 효과
방송 외에도 “답변이 쌓이는 공간”

Q&A 아카이브

팬 입장에서:

“내가 보낸 메시지가 의미 있었다”는 피드백

8. 악성 유저 / 스팸 / 리스크 대응
8.1 기본 방어 장치
레이트 리밋

DM: N회 / 일

RT 요청: 없음(불가)

메시지 길이 제한

URL 제한

8.2 스트리머 제어권
유저 단위 차단

키워드 차단

DM 수신 제한 모드

후원자만 허용

뱃지 이상만 허용

8.3 신고 & 감사 로그
모든 메시지 immutable log 저장

관리자 검토 가능

향후 선정산/법무 대비

9. 메시지 상태 머신 (개발자용)
ViewerDM
  ├─ created
  ├─ read
  ├─ replied_private
  ├─ replied_public
  ├─ retweeted
  └─ blocked

DonationMessage
  ├─ created
  ├─ published
  └─ archived
10. 이 설계의 핵심 효과 요약
채팅 소음 ❌

스트리머 중심 커뮤니케이션 ⭕

팬 메시지의 “격상 구조” ⭕

방송 외 시간에도 살아있는 기록 ⭕

데이터/관계/후원 구조가 자연스럽게 연결 ⭕

11. 다음 편 예고 (Part 4)
다음 문서에서는 가장 민감한 파트로 들어갑니다.

📘 Part 4. 치즈 데이터 수집 전략 (권한 없이 가능한 현실적 방법)
공식 Session 이벤트가 안 될 때의 플랜 B

수동/지연/확정 상태 설계

데이터 정합성 유지 방법

“선정산”으로 이어지는 데이터 기준

👉 이 파트가 완성되면 ‘이게 사업이 될 수 있는가’가 명확해집니다.

계속 진행하겠습니다.

나의 말:
좋습니다. 계속해주세요
ChatGPT의 말:
좋습니다. 이어서 📘 Melt 개발자 문서 – Part 4로 진행하겠습니다.
이번 파트는 가장 현실적이고, 가장 사업적인 파트입니다.

“권한 신청 없이, 비공식 API를 핵심에 쓰지 않으면서
치즈 데이터를 어떻게 ‘쓸 수 있는 상태’로 만들 것인가?”

를 정면으로 다룹니다.

📘 Melt 개발자 문서
Part 4. 치즈 데이터 수집 전략 (권한 없이 가능한 현실적 방법)
1. 이 파트의 전제 (아주 중요)
다시 한 번 못 박고 갑니다.

❌ 치즈 결제를 API로 직접 실행하지 않는다

❌ 치즈 잔액 / 후원 내역을 스크래핑하지 않는다

❌ 비공식 API에 핵심 비즈니스를 의존하지 않는다

❌ “실시간 완벽 자동화”를 초기 목표로 두지 않는다

대신 목표는 이것입니다.

“후원 데이터의 ‘정합성’과 ‘누적 신뢰도’를 확보한다”

선정산, 통계, 뱃지, VIP 관리에 필요한 건
초 단위 실시간성이 아니라
신뢰 가능한 원장과 확정 기준입니다.

2. Melt에서 말하는 “치즈 데이터”의 정의
Melt에서 다루는 데이터는 다음 3종류로 나뉩니다.

구분	의미
Intent	후원을 시도했다
Occurred	실제 후원이 발생했다
Confirmed	스트리머 기준으로 확인/확정되었다
이 3단계를 분리하지 않으면,
초기 서비스는 반드시 무너집니다.

3. 치즈 데이터 상태 모델 (핵심 설계)
3.1 Donation Record 상태값
PENDING
  └─ 사용자가 치즈 후원 UI를 열었음

OCCURRED
  └─ 후원이 실제로 발생했을 가능성이 높음

CONFIRMED
  └─ 스트리머 기준으로 확정됨
📌 중요

통계, 뱃지, 선정산은 CONFIRMED 기준만 사용

공개 피드 노출은 OCCURRED 이상부터 가능

4. 상태 전환 전략 (권한 없는 현실적 접근)
4.1 PENDING 생성 (가장 쉬움)
언제 생성되나?

Melt에서 [치즈 보내기] 클릭

치지직 후원 UI로 이동 직전

DonationIntent
- user_id
- channel_id
- created_at
- status = PENDING
📌 이 데이터는 “후원이 일어났다는 주장”이 아니라
UX 추적용 이벤트입니다.

4.2 OCCURRED 판정 (현실적인 기준)
권한 신청 없이 갈 경우,
OCCURRED 판정은 확률적 + UX 기반으로 갑니다.

가능한 신호들
사용자가:

치지직 후원 UI 방문 후

Melt로 돌아와

메시지를 입력/저장

시간 기준:

PENDING 이후 합리적 시간 내 (예: 5분 이내)

스트리머가:

“새 후원 있음”으로 인지

이 경우:

DonationEvent
- status = OCCURRED
- source = user_flow
📌 이 단계의 데이터는:

공개 피드 노출 가능

통계/정산에는 아직 미반영

4.3 CONFIRMED 판정 (가장 중요)
CONFIRMED는 반드시 스트리머 기준으로만 한다

방법은 단계적으로 갑니다.

5. CONFIRMED 전략 – 3단계 접근
5.1 단계 1 (초기 MVP): 스트리머 수동 확인
가장 현실적이고 안전한 방식입니다.

UX 예시
스트리머 대시보드:

“미확정 후원” 리스트

총액 요약

스트리머 액션:

[확인] 클릭

또는 “오늘 후원 총액 입력”

DonationEvent
- status = CONFIRMED
- confirmed_by = creator
- confirmed_at
📌 이 방식의 장점

법적/정산 리스크 최소

선정산 서비스의 “검증 프로세스”와 자연스럽게 연결

5.2 단계 2 (중간): Session 이벤트 병행 (가능한 경우)
스트리머가 Melt 로그인

공식 Session API로 Donation 이벤트 수신 가능 시

자동 CONFIRMED 처리

source = session_event
📌 단,

Session 이벤트가 불안정하거나 제한되면

자동 CONFIRMED는 즉시 중단 가능해야 함

5.3 단계 3 (장기): 정산 리포트 기반 확정
월/주 단위로

치지직 정산 내역과 Melt 데이터 대사

오차 범위 내 자동 확정

👉 이 단계가 곧 선정산의 기술적 기반

6. 왜 이 구조가 “선정산”에 유리한가
선정산은 단순히 “돈을 먼저 주는 것”이 아닙니다.

“확정 가능한 미래 현금흐름만을 할인해서 지급”

Melt의 구조는:

PENDING → OCCURRED → CONFIRMED

모든 상태 변경에 로그 존재

누가 언제 확정했는지 추적 가능

👉 이건
금융/팩토링/매출채권 관리 구조와 동일합니다.

7. 데이터 모델 (정제 버전)
donation_intents
- id
- viewer_user_id
- channel_id
- created_at

donation_events
- id
- intent_id
- amount (nullable)
- status (PENDING / OCCURRED / CONFIRMED)
- source (user_flow / session / manual)
- occurred_at
- confirmed_at
8. 공개 피드 노출 기준 정리
상태	공개 피드	통계/뱃지	선정산
PENDING	❌	❌	❌
OCCURRED	⭕	❌	❌
CONFIRMED	⭕	⭕	⭕
9. 이 파트의 핵심 요약
“완벽한 자동화”는 초기 목표가 아니다

데이터 상태를 나누면 모든 문제가 풀린다

스트리머 확인 = 가장 강력한 신뢰 기준

이 구조는 곧바로 선정산으로 확장 가능

API가 늘어나면 자동화 비중만 점진적으로 높이면 된다

10. 다음 편 예고 (Part 5)
다음은 이 데이터 위에 가치가 얹히는 순간입니다.

📘 Part 5. 통계 · 뱃지 · VIP 시스템 설계
누적 치즈 기반 뱃지 설계

뱃지가 UX·수익에 미치는 영향

스트리머가 “팬을 관리하는 방식”

뱃지 → 전용 콘텐츠 → 수익 확장

👉 여기까지 오면 Melt는 ‘툴’이 아니라 ‘플랫폼’이 됩니다.

계속 진행하겠습니다.

나의 말:
좋습니다. 계속해주세요
ChatGPT의 말:
좋습니다. 이어서 📘 Melt 개발자 문서 – Part 5를 진행하겠습니다.
이번 파트는 **“데이터가 실제 ‘가치’로 전환되는 지점”**을 다룹니다.

치즈 데이터 → 관계 데이터 → 권한 → 콘텐츠 → 수익
이 흐름을 설계 수준에서 고정합니다.

📘 Melt 개발자 문서
Part 5. 통계 · 뱃지 · VIP 시스템 설계
1. 이 파트의 핵심 질문
Melt가 단순히
“방송 꺼진 뒤에도 후원받는 페이지”에 머무르지 않으려면
반드시 이 질문에 답해야 합니다.

“스트리머와 팬의 관계를 어떻게 ‘구조화’할 것인가?”

그 해답이 바로:

누적 가능한 지표

비교 가능한 등급

권한으로 연결되는 뱃지

입니다.

2. Melt 통계 시스템의 기본 철학
2.1 실시간보다 중요한 것
Melt의 통계는:

❌ 초 단위 실시간

❌ 화려한 대시보드

보다,

⭕ 정합성

⭕ 설명 가능성

⭕ 정산/선정산 연결 가능성

을 우선합니다.

즉,

“왜 이 수치가 이렇게 나왔는지 설명할 수 있어야 한다”

2.2 통계는 반드시 ‘CONFIRMED’ 기준
Part 4에서 정의한 상태 모델을 그대로 이어갑니다.

PENDING / OCCURRED → 참고용

CONFIRMED → 공식 수치

이 원칙은:

뱃지

VIP

선정산
모두에 동일하게 적용됩니다.

3. 핵심 통계 지표 정의
3.1 스트리머 기준 지표
지표	설명
Total Confirmed Cheese	누적 확정 치즈
Period Cheese (D/W/M)	기간별 확정 치즈
Active Supporters	최근 N일 후원자 수
Repeat Rate	재후원 비율
Time Heatmap	시간대별 후원 분포
👉 “방송 중 vs 방송 외” 비교도 가능

3.2 팬(시청자) 기준 지표
지표	설명
Lifetime Cheese	해당 채널 누적 후원
Period Cheese	기간별 후원
Last Support	마지막 후원 시점
Current Badge	현재 보유 뱃지
📌 팬에게 보여주는 정보는
항상 ‘자기 자신’ 기준만 공개

4. Melt 뱃지 시스템 설계 (핵심)
4.1 뱃지의 본질
Melt에서 뱃지는:

단순한 장식 ❌

NFT ❌ (초기엔)

“관계의 깊이를 시각화한 권한 토큰”

입니다.

4.2 뱃지 기준
기본 기준: 누적 CONFIRMED 치즈

예시 (스트리머별 커스터마이즈 가능):

Tier	누적 치즈
Bronze	10,000
Silver	50,000
Gold	200,000
Platinum	1,000,000
📌 중요한 점:

뱃지는 채널 단위

A 스트리머 Gold ≠ B 스트리머 Gold

4.3 뱃지 계산 로직
SUM(donation_events.amount)
WHERE
  viewer_id = X
  AND channel_id = Y
  AND status = CONFIRMED
조건 충족 시:

즉시 승급

강등 ❌ (기본 정책)

5. 뱃지의 UX 노출 지점
5.1 시청자 기준
공개 피드 닉네임 옆

RT된 메시지 작성자 표시

개인 프로필 카드

5.2 스트리머 기준
인박스에서 DM 정렬

상위 뱃지 우선

RT 후보 추천

VIP 리스트

6. 뱃지 → 권한 매핑 (중요 확장 포인트)
뱃지는 단순 표시에서 끝나지 않습니다.

6.1 기본 권한 매핑 예시
뱃지	권한
Silver+	DM 우선 노출
Gold+	RT 후보 가중치
Platinum	전용 콘텐츠 접근
6.2 “뱃지별 콘텐츠”의 의미
뱃지별 콘텐츠는:

팬클럽 ❌

멤버십 ❌

“이미 후원한 사람에게만 열리는 보상 공간”

6.3 콘텐츠 형태 예시
비공개 글

이미지 / 음성 메시지

쿠폰 코드

외부 링크

방송 외 근황 공유

📌 핵심:

추가 결제 없음

뱃지는 ‘열쇠’

7. VIP 시스템 (뱃지의 상위 개념)
7.1 VIP 정의
VIP는:

단순 최고 뱃지 ❌

자동 산출 ❌

“스트리머가 명시적으로 관리하는 관계 그룹”

7.2 VIP 선정 기준 (예시)
Platinum 이상 + 스트리머 수동 지정

장기 후원자

특정 프로젝트 기여자

7.3 VIP 전용 기능
DM 최상단 고정

RT 제한 완화

전용 콘텐츠

향후: 선정산 우선 대상

8. 데이터 모델 (뱃지/통계)
user_channel_stats
- user_id
- channel_id
- total_confirmed_cheese
- last_donation_at
- updated_at

badges
- id
- channel_id
- tier
- threshold_amount

user_badges
- user_id
- channel_id
- badge_id
- achieved_at

vip_users
- user_id
- channel_id
- assigned_at
9. 이 설계가 만들어내는 구조적 효과
팬은 “기록이 남는다”

스트리머는 “누가 중요한지 한눈에 안다”

후원은 “일회성 소비”가 아니다

방송 외 시간에도 관계가 유지된다

선정산은 “논리적 귀결”이 된다

10. 다음 편 예고 (Part 6)
다음 파트는 사업과 법의 경계로 들어갑니다.

📘 Part 6. 선정산 서비스로의 확장 구조 (Preview)
왜 Melt는 선정산을 할 수 있는가

기술적으로 무엇이 이미 준비되어 있는가

어디까지가 ‘플랫폼’, 어디부터가 ‘금융’

MVP 단계에서 절대 하면 안 되는 것

👉 이 파트까지 오면
“Melt는 왜 위험하지 않은가”를 명확히 설명할 수 있습니다.

계속 진행하겠습니다.

나의 말:
좋습니다. 계속해주세요
ChatGPT의 말:
좋습니다. 이어서 📘 Melt 개발자 문서 – Part 6를 진행하겠습니다.
이번 파트는 가장 민감하지만, 가장 중요한 확장 지점입니다.

“왜 Melt는 선정산을 ‘해도 되는 구조’인가?”
“어디까지가 플랫폼이고, 어디부터가 금융인가?”

를 기술·운영 관점에서 명확히 분리합니다.

📘 Melt 개발자 문서
Part 6. 선정산 서비스로의 확장 구조 (금융 리스크를 만들지 않는 설계)
1. 이 파트의 핵심 결론 (먼저 요약)
Melt는 ‘돈을 만들어내는 서비스’가 아니다.
Melt는 ‘이미 발생한 수익을 구조화하는 서비스’다.

이 한 줄이:

법적 리스크

금융 규제

기술적 책임 범위

를 모두 가릅니다.

2. 선정산이란 무엇인가 (Melt 기준 정의)
2.1 일반적인 오해
선정산 = ❌ “아직 벌지 않은 돈을 미리 준다”

이 정의는 위험합니다.

2.2 Melt의 선정산 정의
“이미 발생했고, 발생이 반복적으로 확인되는
수익 흐름을 기준으로,
미래 지급분을 할인해 먼저 지급한다.”

즉,

❌ 투기

❌ 신용 창출

❌ 대출

이 아니라,

⭕ 매출채권(Receivable) 관리

⭕ 현금흐름 최적화

⭕ 팩토링과 유사한 구조

입니다.

3. Melt 구조가 선정산에 유리한 이유 (기술적)
Part 4~5에서 쌓아온 구조를 다시 봅니다.

3.1 Melt는 이미 ‘원장’을 갖고 있다
DonationEvent

상태 분리 (PENDING / OCCURRED / CONFIRMED)

Confirmed 기준 집계

스트리머 직접 확인 로그

👉 이건 금융에서 말하는 거래 원장(Ledger) 입니다.

3.2 Melt는 “예측”이 아니라 “통계”를 쓴다
선정산에서 중요한 건:

다음 달에 잘 될 것 같음 ❌

최근 N개월 동안 이렇게 벌었음 ⭕

Melt는 이미:

기간별 확정 수익

시간대별 패턴

재후원율

팬 분포

를 계산합니다.

4. Melt 선정산의 기본 원칙 (절대선)
원칙 1. Melt는 돈을 직접 빌려주지 않는다
Melt = 플랫폼

지급 주체는 별도 법인/파트너 가능

원칙 2. CONFIRMED 데이터만 사용
OCCURRED / PENDING 절대 사용 ❌

원칙 3. 스트리머가 명시적으로 신청
자동 제공 ❌

opt-in 구조

5. 선정산 기능의 단계별 확장 (현실적인 로드맵)
Phase 0. “선정산 가능성 지표”만 제공 (가장 안전)
아직 돈은 오가지 않습니다.

제공 정보
최근 30/60/90일 평균 확정 치즈

변동성 지표

최대 안전 선정산 한도(참고값)

📌 금융 행위 아님
→ 단순 정보 제공

Phase 1. “정산 예정액 기준” 선지급 (보수적)
치지직 정산일이 가까운 확정 금액

이미 정산 예정인 금액 일부를 미리 지급

📌 성격:

지급 시점만 앞당김

리스크 극히 낮음

Phase 2. “평균 수익 기반” 선정산 (본격)
최근 N개월 평균

할인율 적용

상한선 존재

📌 이 단계부터:

금융 파트너 연계 필수

내부 리스크 모델 필요

6. 선정산 산식 예시 (개념 수준)
EligibleAmount =
  AVG(MonthlyConfirmedCheese, last 3 months)
  × RiskFactor
  × AdvanceRate
RiskFactor:

변동성

활동 지속성

AdvanceRate:

50~80% (보수적)

📌 Melt는 산식만 제공 가능
📌 실제 지급은 파트너가 결정

7. 데이터 요구사항 (이미 준비된 것)
Melt가 이미 갖고 있는 데이터:

월별 확정 수익

스트리머별 히스토리

팬 분산도

이벤트 로그

👉 추가 수집 필요 거의 없음

8. Melt가 절대 하지 말아야 할 것 (중요)
❌ 하면 안 되는 것
이자율 명시

“대출” 표현

자동 한도 제공

신용 점수화

개인 자금 직접 운용

⭕ 반드시 유지할 표현/구조
“선정산 가능성”

“참고 지표”

“신청 기반”

“외부 지급 주체”

9. 법/규제 관점에서의 Melt 포지션
Melt = 데이터/관계/정산 보조 플랫폼

결제 ❌

자금 보관 ❌

이자 수취 ❌

금융상품 판매 ❌

👉 이 포지션을 끝까지 유지해야 함

10. 이 파트의 핵심 요약
Melt는 이미 선정산에 필요한 기술을 갖고 있다

중요한 건 하지 않는 것

데이터 상태 분리가 모든 리스크를 줄인다

선정산은 “확장 옵션”이지 “필수 기능”이 아니다

Melt는 금융이 아니라 인프라다

11. 다음 편 예고 (Part 7)
다음 파트는 운영과 확장입니다.

📘 Part 7. 운영 · 리스크 · 스케일 전략
API 변경/차단에 대한 대응

비공식 API 의존 최소화 전략

서비스 커질수록 안전해지는 구조

“치지직과 싸우지 않는 성장”

👉 이 파트까지 오면
Melt는 ‘될 수 있는 서비스’가 아니라 ‘지속 가능한 서비스’가 됩니다.

계속 진행하겠습니다.

나의 말:
좋습니다. 계속해주세요
ChatGPT의 말:
좋습니다. 이어서 📘 Melt 개발자 문서 – Part 7로 계속하겠습니다.
이번 파트는 **“이 서비스가 커질수록 왜 더 안전해지는가”**를 설명하는 운영·리스크·스케일 전략입니다.

📘 Melt 개발자 문서
Part 7. 운영 · 리스크 · 스케일 전략
— “치지직과 싸우지 않고, 오래 가는 구조”
1. 이 파트의 핵심 메시지
Melt는 기능으로 커지는 서비스가 아니라
구조로 오래가는 서비스다.

즉,

새로운 API가 생겨도 흔들리지 않고

API가 막혀도 핵심 가치는 유지되며

플랫폼 정책 변화에 적응할 수 있어야 합니다.

2. Melt의 리스크 분류 (명확히 나누기)
운영 리스크를 4가지로 나눕니다.

리스크	예시
기술 리스크	API 변경, 이벤트 미수신
정책 리스크	비공식 API 제한
운영 리스크	스팸, 악성 유저
사업 리스크	선정산 오해, 금융 규제
Melt는 이 중 어느 하나에도 과도하게 의존하지 않는 구조를 선택합니다.

3. 기술 리스크 대응 전략
3.1 공식 API가 줄어들거나 바뀌는 경우
영향 범위
로그인(OAuth)

Session 이벤트(있다면)

대응 원칙
❌ 공식 API가 있어야만 서비스가 되는 구조 금지

⭕ 핵심 기능은 Melt 내부에서 완결

👉 OAuth만 살아있으면:

로그인 가능

후원 UI 연결 가능

메시지/피드/통계 가능

3.2 Session 이벤트가 불안정한 경우
이미 설계로 대응되어 있습니다.

자동 CONFIRMED ❌

스트리머 확인 기반 CONFIRMED ⭕

Session 이벤트는 보조 신호

👉 이벤트 미수신 = 서비스 중단 ❌
👉 이벤트 미수신 = 자동화 감소 ⭕

4. 비공식 API에 대한 Melt의 장기 전략
4.1 원칙 재정의
비공식 API는 “있으면 편한 것”이지
“없으면 안 되는 것”이 아니다

4.2 사용 허용 범위 (재확인)
채널 검색

방송 여부 표시

썸네일/메타데이터

📌 모두 UX 보조용

4.3 보호조치 대비 설계
호출 빈도 최소화

서버 캐싱

클라이언트 직접 호출 금지

User-Agent 명확화

👉 보호조치 발생 시:

해당 기능만 비활성화

핵심 기능 영향 없음

5. 운영 리스크 (유저/콘텐츠)
5.1 Melt가 채팅보다 안전한 이유
일반 채팅 서비스의 문제:

실시간 감정 폭주

다대다 충돌

모더레이션 지옥

Melt는:

1:1 구조

공개는 스트리머 승인

후원 기반 메시지

👉 구조적으로 분쟁이 적음

5.2 스팸/악성 유저 대응 전략
기본 장치
DM 레이트 리밋

신규 계정 제한

후원 없는 DM 제한

스트리머 권한
유저 차단

DM 수신 조건 설정

RT 권한 독점

5.3 로그 & 감사
모든 메시지 immutable log

상태 변경 기록

관리자 열람 가능

👉 선정산/법무 대응 기반

6. 사업 리스크 (금융 오해 방지)
6.1 가장 위험한 순간
“이거 대출 아닌가요?”

이 질문이 나오는 순간이
가장 큰 리스크 포인트입니다.

6.2 Melt의 일관된 커뮤니케이션 원칙
❌ “빌려준다”

❌ “이자”

❌ “한도”

⭕ “정산 예정 수익”

⭕ “선지급”

⭕ “참고 지표”

👉 문구 통일은 기술만큼 중요

7. 스케일 전략: 커질수록 안전해지는 이유
7.1 유저 수 증가 ≠ 리스크 증가
일반 플랫폼:

유저 증가 → 소음/분쟁 증가

Melt:

유저 증가 → 데이터 신뢰도 증가

스트리머 기준 CONFIRMED 증가

선정산 정확도 상승

7.2 스트리머 수 증가의 효과
개별 스트리머 의존도 감소

평균 데이터 안정화

플랫폼 협상력 증가

8. 치지직과의 관계 전략
8.1 Melt는 경쟁자가 아니다
치지직의:

트래픽 ⭕

결제 ⭕

후원 ⭕

Melt는:

정리

분석

관계 관리

👉 역할 분리

8.2 장기적으로 가능한 포지션
공식 파트너

크리에이터 도구

데이터 리포트 레이어

📌 이때도:

Melt는 “대체재”가 아니라 “보완재”

9. 운영 체크리스트 (실무용)
Daily
후원 CONFIRMED 수

미확정 이벤트 수

스팸 리포트

Weekly
데이터 오차

스트리머 피드백

UX 이탈 포인트

Monthly
정책 변경 체크

API 변경 로그

선정산 요청 분석

10. 이 파트의 핵심 요약
Melt는 API에 덜 의존할수록 강해진다

자동화보다 확정 기준이 중요하다

비공식 API는 항상 보조

커질수록 데이터 신뢰도가 쌓인다

치지직과 경쟁하지 않는다

11. 다음 편 예고 (Part 8 – Final)
다음 파트는 정리이자 실행 파트입니다.

📘 Part 8. MVP → 정식 서비스 실행 로드맵
Phase 0 / 1 / 2 기능 정리

지금 바로 만들 수 있는 것

나중에 해도 되는 것

개발 우선순위 & 팀 구성

👉 이 파트가 끝나면
“지금 당장 만들 수 있는 MVP”가 명확해집니다.

계속 진행하겠습니다.

나의 말:
네, 계속해주세요
ChatGPT의 말:
좋습니다. 마무리로 📘 Melt 개발자 문서 – Part 8 (Final) 을 진행하겠습니다.
이번 파트는 **“이제 무엇부터 만들면 되는가”**를 명확히 정리하는 실행 로드맵입니다.

📘 Melt 개발자 문서
Part 8. MVP → 정식 서비스 실행 로드맵 (Final)
1. 이 파트의 목표
이 문서를 여기까지 읽었다면, 이제 필요한 것은 딱 하나입니다.

“지금 당장 만들 수 있는 최소 단위는 무엇이고,
무엇은 일부러 안 만들어야 하는가?”

이 파트는:

기능 우선순위

단계별 범위

팀 구성

기술 선택

을 실행 가능한 수준으로 고정합니다.

2. Melt 개발 단계 요약 (한 장)
전체 로드맵 요약
단계	목표	키워드
Phase 0	개념 검증	후원 + 메시지
Phase 1	MVP 출시	방송 외 후원
Phase 2	확장	뱃지·통계
Phase 3	옵션	선정산
3. Phase 0 – 개념 검증 (2~3주)
3.1 목표
“방송이 꺼진 상태에서도 팬이 치즈를 보낼까?”

“스트리머가 이 메시지를 확인하고 답할까?”

이 질문에만 답하면 됩니다.

3.2 반드시 포함할 기능 (MUST)
사용자
치지직 OAuth 로그인

채널 1개 선택

[치즈 보내기] 버튼

치지직 공식 후원 UI로 이동

메시지 입력 (후원 메시지 / 일반 메시지)

스트리머
인박스 화면

후원 메시지

일반 DM

간단한 답장

수동 “확인” 버튼 (후원 발생 인정)

시스템
메시지 저장

상태 모델 (PENDING / OCCURRED / CONFIRMED)

공개 피드 (최소 형태)

3.3 일부러 빼야 할 것 (MUST NOT)
실시간 자동 후원 수집

통계 대시보드

뱃지

선정산 언급

📌 Phase 0의 목표는 ‘증명’이지 ‘완성’이 아니다

4. Phase 1 – MVP 출시 (1~2개월)
4.1 목표
“방송 외 후원이라는 새로운 루틴을 만든다”

4.2 추가 기능 (SHOULD)
메시징 고도화
공개 피드 정렬

RT 기능

스트리머 답장 공개/비공개 선택

운영 안정성
레이트 리밋

유저 차단

기본 로그/감사

UX
모바일 UI 완성도

후원 후 복귀 UX 개선

메시지 상태 표시

4.3 여전히 하지 말아야 할 것
결제 자동화

비공식 API 핵심 의존

“선정산” 기능 노출

5. Phase 2 – 확장 (3~6개월)
5.1 목표
“후원이 관계로 쌓이게 만든다”

5.2 핵심 기능
통계
기간별 CONFIRMED 치즈

유저별 누적

스트리머 대시보드

뱃지
누적 치즈 기반

채널별 커스터마이즈

피드/DM 노출

권한
뱃지별 DM 우선

RT 추천 가중치

뱃지 전용 콘텐츠

5.3 이 시점의 Melt 정체성
“방송 외 팬 관리 툴”

이 시점부터:

스트리머 retention ↑

팬 반복 후원 ↑

데이터 신뢰도 ↑

6. Phase 3 – 선정산 (Option, 선택적)
6.1 절대 전제
자동 제공 ❌

금융 표현 ❌

플랫폼 단독 ❌

6.2 가능한 최소 기능
“선정산 가능성 지표”

참고 한도 표시

외부 파트너 연계

📌 이 단계는
사업 상황·법무·파트너십이 모두 맞을 때만 진행

7. 기술 스택 권장안 (실무 기준)
Frontend
Next.js / React

Mobile-first

SSR 최소화

Backend
Node.js (NestJS or Express)

REST API

JWT + OAuth Token Vault

DB
PostgreSQL

이벤트 원장 테이블 분리

상태 기반 인덱싱

Infra
Vercel / AWS

로그 중심 운영

에러 트래킹 필수

8. 최소 팀 구성 (현실적)
역할	필요도
Full-stack	★★★★★
Backend	★★★★
Product/UX	★★★
법무/자문	★★ (후반)
📌 초반엔 2명으로도 충분

9. 지금 당장 할 수 있는 To-do 리스트
이번 주
DB 스키마 확정

OAuth 로그인 구현

메시지 모델 구현

다음 주
후원 CTA 연결

스트리머 인박스

상태 전환 로직

1개월 내
5~10명 스트리머 파일럿

실제 방송 외 후원 데이터 확인

10. Melt의 최종 정체성 (정리)
Melt는 ‘후원 서비스’가 아니다.
Melt는 ‘후원이 계속되게 만드는 구조’다.

치지직을 대체하지 않는다

치지직을 침범하지 않는다

치지직이 하지 않는 일을 한다

이 설계는:

기술적으로 안전하고

정책적으로 유연하며

사업적으로 확장 가능하다

✅ 여기까지가 Melt 개발자 문서 v1 (완결) 입니다.
다음으로 가능하게 이어질 수 있는 작업은:

📐 DB 스키마 상세 설계

🧩 API 엔드포인트 명세(OpenAPI)

📱 모바일 화면 IA / 와이어프레임

🧪 Phase 0 MVP 구현 체크리스트

📄 외부 공유용 요약 문서(스트리머/파트너용)

원하시는 다음 단계 하나를 짚어주시면, 그 지점부터 바로 실무 수준으로 내려가서 같이 만들어보겠습니다.

나의 말:
좋습니다. 코드에 관련된 부분들, 특히 전체 아키텍쳐, api 엔드포인트, 치지직 api 연동, 프런트엔드 (처음부터 모바일 최적화해서, 컴퓨터에서 열더라도 양쪽을 마스킹), db 스키마 등을 상세적이고 구체적으로 다뤄주시고, 코드 예시도 넣어주셔도 됩니다.
ChatGPT의 말:
좋습니다. 아래는 Melt v1(권한 신청 없이 / “있는 것만”) 전제를 그대로 유지하면서, 바로 개발에 착수할 수 있게 전체 아키텍처 → DB 스키마 → 백엔드 API → 치지직 OAuth 연동 → 프런트(모바일 고정 + 데스크톱 마스킹) → 코드 예시까지 한 번에 “실무형”으로 내려쓴 Dev Spec + Starter 코드입니다.

전제 고정

Melt 메시지는 치지직 채팅에 절대 남지 않음(완전 분리)

치즈 충전/후원은 치지직 공식 UI(웹/앱 화면)로 이동해서 처리

후원 “발생/확정”은 v1에서는 스트리머 수동 확인(Confirmed) 중심 (Session 이벤트 자동화는 옵션)

0) 전체 아키텍처 (실행 가능한 형태)
컴포넌트
Web (Next.js): 모바일 UI 고정 + 데스크톱 양옆 마스킹

API Server (Node/NestJS 또는 Express): OAuth, 메시지/피드/DM/RT, 크리에이터 대시보드, 수동 Confirm

DB (PostgreSQL): 이벤트 원장 중심 (donation_intents / donation_events / messages / retweets)

Queue(옵션): 나중에 Session 이벤트 수신/집계용 (BullMQ/Redis 등)

핵심 데이터 흐름
로그인: Web → API → CHZZK OAuth → API → Web

후원: Web에서 “치즈 보내기” → 치지직 후원 UI로 이동 → 사용자가 돌아오면 Melt에서 메시지 작성/등록

확정: 크리에이터가 대시보드에서 “확정(Confirm)” 클릭 → CONFIRMED 기준 통계/뱃지 반영

1) DB 스키마 (Postgres, “원장 + 상태” 설계)
핵심: PENDING / OCCURRED / CONFIRMED 상태를 DB에서 강제
통계/뱃지/선정산(미래)을 위해 “원장”을 먼저 세웁니다.

1.1 ENUM 및 기본 테이블 SQL
-- 1) enums
DO $$ BEGIN
  CREATE TYPE user_role AS ENUM ('viewer', 'creator', 'admin');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TYPE message_type AS ENUM ('donation', 'dm', 'creator_post', 'creator_reply');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TYPE visibility AS ENUM ('public', 'private');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TYPE donation_status AS ENUM ('PENDING', 'OCCURRED', 'CONFIRMED');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TYPE donation_source AS ENUM ('user_flow', 'manual', 'session');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- 2) users
CREATE TABLE IF NOT EXISTS users (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chzzk_user_id   TEXT UNIQUE,               -- OAuth로 식별되는 유저 키 (정확한 키는 docs 기준으로 매핑)
  display_name    TEXT,
  role            user_role NOT NULL DEFAULT 'viewer',
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 3) channels (Melt에서 관리하는 "스트리머 채널")
CREATE TABLE IF NOT EXISTS channels (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chzzk_channel_id TEXT UNIQUE NOT NULL,
  name            TEXT,
  owner_user_id   UUID REFERENCES users(id),
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_channels_owner ON channels(owner_user_id);

-- 4) oauth_tokens (서버에 안전 저장: 반드시 암호화/키관리)
CREATE TABLE IF NOT EXISTS oauth_tokens (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  access_token  TEXT NOT NULL,
  refresh_token TEXT,
  expires_at    TIMESTAMPTZ,
  scope         TEXT,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_oauth_tokens_user ON oauth_tokens(user_id);

-- 5) donation_intents: "치즈 보내기" 버튼 누른 순간 생성 (PENDING의 근거)
CREATE TABLE IF NOT EXISTS donation_intents (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  viewer_user_id  UUID NOT NULL REFERENCES users(id),
  channel_id      UUID NOT NULL REFERENCES channels(id),
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_intents_viewer ON donation_intents(viewer_user_id);
CREATE INDEX IF NOT EXISTS idx_intents_channel ON donation_intents(channel_id);

-- 6) donation_events: 실제 후원 “발생/확정”의 원장
CREATE TABLE IF NOT EXISTS donation_events (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  intent_id        UUID REFERENCES donation_intents(id),
  channel_id       UUID NOT NULL REFERENCES channels(id),
  viewer_user_id   UUID REFERENCES users(id),
  amount           BIGINT,  -- 치즈/원 단위는 정책 결정 (권장: 원 단위 integer)
  status           donation_status NOT NULL DEFAULT 'OCCURRED',
  source           donation_source NOT NULL DEFAULT 'user_flow',
  occurred_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  confirmed_at     TIMESTAMPTZ,
  confirmed_by     UUID REFERENCES users(id), -- creator/admin
  note             TEXT
);

CREATE INDEX IF NOT EXISTS idx_donations_channel_time ON donation_events(channel_id, occurred_at DESC);
CREATE INDEX IF NOT EXISTS idx_donations_viewer ON donation_events(viewer_user_id);

-- 7) messages: Melt 내부 메시징 (치지직 채팅과 완전 분리)
CREATE TABLE IF NOT EXISTS messages (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id        UUID NOT NULL REFERENCES channels(id),
  author_user_id    UUID NOT NULL REFERENCES users(id),
  type              message_type NOT NULL,
  visibility        visibility NOT NULL,
  content           TEXT NOT NULL,
  related_donation_id UUID REFERENCES donation_events(id),
  reply_to_message_id UUID REFERENCES messages(id),
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_messages_channel_time ON messages(channel_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_author ON messages(author_user_id);

-- 8) retweets: RT(공개 전환) 기록
CREATE TABLE IF NOT EXISTS retweets (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id       UUID NOT NULL REFERENCES channels(id),
  message_id       UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  creator_user_id  UUID NOT NULL REFERENCES users(id),
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_retweet_message ON retweets(message_id);
1.2 통계/뱃지 테이블(Phase 2를 미리 준비)
CREATE TABLE IF NOT EXISTS badges (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  channel_id   UUID NOT NULL REFERENCES channels(id),
  tier        TEXT NOT NULL,
  threshold_amount BIGINT NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(channel_id, tier)
);

CREATE TABLE IF NOT EXISTS user_badges (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id    UUID NOT NULL REFERENCES users(id),
  channel_id UUID NOT NULL REFERENCES channels(id),
  badge_id   UUID NOT NULL REFERENCES badges(id),
  achieved_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, channel_id)
);
2) 백엔드 API 엔드포인트 (MVP 기준)
원칙: Melt API는 치지직 결제를 “실행”하지 않음.
치지직 연동은 OAuth(로그인/식별) + (옵션) 유저/채널 메타 조회만.

2.1 Auth / OAuth
GET /auth/chzzk/login

치지직 OAuth authorize URL로 리다이렉트

GET /auth/chzzk/callback?code=...&state=...

code → token 교환, users/me 조회(가능하면), 세션 생성(우리 JWT)

POST /auth/logout

우리 세션/JWT 폐기

2.2 Channel
GET /channels/:chzzkChannelId

Melt 내부 채널 프로필

POST /channels/:chzzkChannelId/follow (옵션)

Melt 내부 “즐겨찾기” (치지직 팔로우와 무관)

2.3 Donation Flow (핵심)
POST /donations/intent

body: { chzzkChannelId }

서버가 donation_intents 생성 후 intentId 반환

POST /donations/occurred

body: { intentId, message, amount?: number }

“후원했음”을 Melt에 등록(=OCCURRED + DonationMessage 생성)

amount는 v1에서 선택(정합성은 Confirm에서 확정)

POST /donations/:donationEventId/confirm (Creator only)

body: { amount: number }

CONFIRMED로 전환 (confirmed_by, confirmed_at 설정)

2.4 Feed / Messages
GET /feed?chzzkChannelId=...&cursor=...

public 메시지만: DonationMessage(public) + CreatorPost + RT된 DM

POST /messages/dm (Viewer → Creator)

body: { chzzkChannelId, content } (private)

GET /creator/inbox?chzzkChannelId=...

creator만: private DM 리스트 + 미확정 후원 리스트

POST /messages/:messageId/reply

body: { content, visibility: 'private'|'public' }

POST /messages/:messageId/retweet

creator만: DM을 public로 전환 (retweets 생성 + message visibility 변경 또는 RT 레코드 기반 노출)

2.5 Stats (Phase 2)
GET /creator/stats/summary?chzzkChannelId=...&range=30d

GET /creator/stats/supporters?chzzkChannelId=...

3) 치지직 OAuth 연동 (Node/Express 예시)
주의: 치지직 API 호출/스코프/응답 필드는 공식 문서 기준으로 정확히 맞춰야 합니다.
여기서는 “패턴”을 보여드립니다(실제 엔드포인트/필드명은 docs에 맞게 수정).

3.1 환경 변수
CHZZK_CLIENT_ID=...
CHZZK_CLIENT_SECRET=...
CHZZK_REDIRECT_URI=https://api.melt.gg/auth/chzzk/callback
APP_JWT_SECRET=...
TOKEN_ENCRYPTION_KEY=...  # AES-GCM 등
3.2 Express 라우트 (login/callback)
// src/auth/chzzkAuth.ts
import express from "express";
import crypto from "crypto";
import axios from "axios";
import jwt from "jsonwebtoken";

const router = express.Router();

function base64url(input: Buffer) {
  return input.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function createState(): string {
  return base64url(crypto.randomBytes(24));
}

// 1) login: authorize로 리다이렉트
router.get("/chzzk/login", (req, res) => {
  const state = createState();
  // TODO: state를 Redis/DB에 저장해서 CSRF 방지 (state -> nonce -> redirect target)
  const authorizeUrl = new URL("https://chzzk.naver.com/account-interlock"); // docs 기준
  authorizeUrl.searchParams.set("clientId", process.env.CHZZK_CLIENT_ID!);
  authorizeUrl.searchParams.set("redirectUri", process.env.CHZZK_REDIRECT_URI!);
  authorizeUrl.searchParams.set("state", state);
  // authorizeUrl.searchParams.set("scope", "...."); // docs에 맞게
  res.redirect(authorizeUrl.toString());
});

// 2) callback: code -> token 교환
router.get("/chzzk/callback", async (req, res) => {
  const { code, state } = req.query as { code?: string; state?: string };
  if (!code || !state) return res.status(400).send("Missing code/state");

  // TODO: state 검증 (Redis/DB)
  try {
    // token endpoint는 docs에 맞게 조정
    const tokenResp = await axios.post(
      "https://api.chzzk.naver.com/auth/v1/token",
      new URLSearchParams({
        grant_type: "authorization_code",
        client_id: process.env.CHZZK_CLIENT_ID!,
        client_secret: process.env.CHZZK_CLIENT_SECRET!,
        code,
        redirect_uri: process.env.CHZZK_REDIRECT_URI!,
      }),
      { headers: { "Content-Type": "application/x-www-form-urlencoded" } }
    );

    const { access_token, refresh_token, expires_in } = tokenResp.data;

    // (권장) users/me로 유저 식별
    const meResp = await axios.get("https://api.chzzk.naver.com/open/v1/users/me", {
      headers: { Authorization: `Bearer ${access_token}` },
    });

    const chzzkUserId = meResp.data?.content?.userId ?? meResp.data?.content?.channelId ?? null;
    const displayName = meResp.data?.content?.nickname ?? null;

    // TODO: DB upsert users + oauth_tokens(암호화)
    // expires_at = now + expires_in

    const appJwt = jwt.sign(
      { sub: chzzkUserId, name: displayName },
      process.env.APP_JWT_SECRET!,
      { expiresIn: "7d" }
    );

    // Web로 리다이렉트 (토큰 전달은 쿠키 권장)
    res
      .cookie("melt_session", appJwt, { httpOnly: true, secure: true, sameSite: "lax" })
      .redirect("https://melt.gg/app");
  } catch (e: any) {
    console.error(e?.response?.data || e);
    res.status(500).send("OAuth failed");
  }
});

export default router;
운영 팁

state는 반드시 서버에서 저장/검증(CSRF 방지)

access/refresh token은 DB에 암호화 저장(AES-GCM + KMS 권장)

“권한 신청 안 함” 전제면, OAuth 스코프는 가능한 최소로 시작

4) 후원 플로우 구현 (MVP: 수동 Confirm 중심)
4.1 Intent 생성 → 치지직 UI로 이동
Backend: POST /donations/intent
// src/routes/donations.ts
router.post("/donations/intent", authRequired, async (req, res) => {
  const { chzzkChannelId } = req.body;
  // 1) channels upsert
  // 2) donation_intents insert
  // 3) intentId 반환
  res.json({ intentId: "uuid", chzzkChannelId });
});
Frontend: 버튼 클릭 시
/donations/intent 호출로 intentId를 만들고

치지직 공식 후원 페이지(가능한 URL/딥링크)로 이동하면서 intentId를 localStorage에 저장

// web/app/(channel)/DonateButton.tsx
export function DonateButton({ chzzkChannelId }: { chzzkChannelId: string }) {
  const onClick = async () => {
    const r = await fetch("/api/donations/intent", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ chzzkChannelId }),
    });
    const { intentId } = await r.json();
    localStorage.setItem("melt_intent_id", intentId);

    // TODO: 실제 치지직 후원 URL은 확인되는 공식 경로/딥링크로.
    // 우선은 채널 페이지로 보내고, 사용자가 치즈 버튼으로 후원하도록 유도하는 방식이 안전.
    window.location.href = `https://chzzk.naver.com/live/${chzzkChannelId}`;
  };

  return (
    <button onClick={onClick} className="w-full rounded-xl py-4 font-bold bg-black text-white">
      치즈 보내기
    </button>
  );
}
“치즈 충전/후원 UI를 치지직에서 직접 활용”은
정확한 딥링크/URL이 공식적으로 안정 제공되는지에 따라 완성도가 갈립니다.
v1에서는 “채널 페이지로 이동 → 치즈 버튼 유도”가 가장 안전한 디폴트입니다.

4.2 Melt로 돌아온 뒤 “후원 메시지 등록”(OCCURRED)
Backend: POST /donations/occurred
router.post("/donations/occurred", authRequired, async (req, res) => {
  const { intentId, message, amount } = req.body;
  // 1) intent 조회 + viewer_user + channel 찾기
  // 2) donation_events insert: status=OCCURRED, amount nullable
  // 3) messages insert: type=donation, visibility=public, related_donation_id 연결
  res.json({ ok: true });
});
Frontend: “방금 후원했어요” 화면에서 제출
const intentId = localStorage.getItem("melt_intent_id");

await fetch("/api/donations/occurred", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ intentId, message: text, amount: null }),
});
4.3 Creator Confirm (CONFIRMED)
Backend: POST /donations/:id/confirm
router.post("/donations/:id/confirm", creatorOnly, async (req, res) => {
  const { amount } = req.body;
  const { id } = req.params;

  // donation_events update:
  // status=CONFIRMED, amount=amount, confirmed_at=now, confirmed_by=currentUser.id
  res.json({ ok: true });
});
5) 메시징/피드/RT 구현 디테일
5.1 DM 생성 (Viewer → Creator, private)
router.post("/messages/dm", authRequired, async (req, res) => {
  const { chzzkChannelId, content } = req.body;
  // messages insert: type='dm', visibility='private'
  res.json({ ok: true });
});
5.2 Creator reply (private/public)
router.post("/messages/:id/reply", creatorOnly, async (req, res) => {
  const { content, visibility } = req.body; // 'private'|'public'
  // messages insert: type='creator_reply', reply_to_message_id = :id
  res.json({ ok: true });
});
5.3 RT (DM → public)
권장 구현 방식(안정적):

DM 원문은 그대로 private 유지

RT는 retweets 테이블에 기록

피드 조회 시 retweets join하여 public feed에 노출

router.post("/messages/:id/retweet", creatorOnly, async (req, res) => {
  const messageId = req.params.id;
  // retweets insert (unique message)
  res.json({ ok: true });
});
5.4 Feed 조회 (public only)
donation message(confirmed/occurred 상관없이 public 가능)

creator post

RT된 DM

creator public reply (옵션)

6) 프런트엔드: “모바일 최적화 + 데스크톱 양옆 마스킹”
6.1 레이아웃 원칙
중앙에 고정된 모바일 캔버스 (예: 420px ~ 480px)

양 옆은 마스킹(어두운 배경 + 블러/그라데이션)

데스크톱에서도 모바일 UI를 그대로 사용 (반응형 복잡도 ↓)

6.2 Next.js App Router 레이아웃 예시 (Tailwind 기준)
// app/layout.tsx
import "./globals.css";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ko">
      <body>
        <div className="min-h-screen w-full bg-neutral-950 text-white">
          {/* Side mask */}
          <div className="fixed inset-0 pointer-events-none">
            <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,rgba(255,255,255,0.06),rgba(0,0,0,0.9))]" />
          </div>

          {/* Center mobile frame */}
          <div className="relative mx-auto min-h-screen w-full max-w-[460px] bg-neutral-900 shadow-2xl">
            {children}
          </div>
        </div>
      </body>
    </html>
  );
}
6.3 “진짜 마스킹” 느낌 강화 (옵션)
좌우에 vignette + blur layer 추가

가운데 프레임에 둥근 모서리(웹에서만)

/* globals.css */
@media (min-width: 768px) {
  .mobile-frame {
    border-radius: 18px;
    margin: 24px auto;
    min-height: calc(100vh - 48px);
    overflow: hidden;
  }
}
<div className="relative mx-auto w-full max-w-[460px] bg-neutral-900 shadow-2xl mobile-frame">
  {children}
</div>
7) 추천 폴더 구조 (실제 운영 기준)
backend
backend/
  src/
    main.ts
    auth/
      chzzkAuth.ts
      session.ts (JWT)
    routes/
      donations.ts
      messages.ts
      feed.ts
      creator.ts
    db/
      pool.ts
      migrations/
    middleware/
      authRequired.ts
      creatorOnly.ts
  package.json
web
web/
  app/
    layout.tsx
    page.tsx
    (auth)/
      login/page.tsx
    (channel)/
      [chzzkChannelId]/
        page.tsx
        donate/page.tsx
    (creator)/
      dashboard/page.tsx
  lib/
    api.ts
  package.json
8) 구현 우선순위 (바로 MVP 뽑는 순서)
DB + Auth (OAuth → 우리 세션)

Channel 프로필(최소) + “치즈 보내기” 버튼(intent 생성 + 치지직 이동)

“후원했어요” 등록(occurred + public donation message 생성)

DM(비공개) + Creator inbox

Confirm(creator가 금액 입력 → confirmed)

Feed (public only) + RT

9) 다음 단계 제안 (원하시는 방향으로 바로 더 깊게)
원하시면 제가 다음 메시지에서 둘 중 하나를 선택해서 “완성형”으로 더 내려드릴게요(질문 없이 그냥 진행 가능합니다).

A안) “백엔드 완성형”
NestJS 기준으로

DTO/Validation

Auth Guard (JWT)

Repository/Service 구조

OpenAPI(Swagger) 스펙까지 자동 생성

B안) “프런트 완성형”
Next.js 기준으로

화면 IA (8~10개 화면)

상태/캐시(react-query)

피드 무한스크롤(cursor pagination)

크리에이터 인박스 UX

원하시는 톤이 “최대한 빠르게 실제로 돌아가게”라면 저는 A안(백엔드 완성형)부터 추천합니다.




선택된 파일 없음선택된 파일 없음
ChatGPT는 실수를 할 수 있습니다. 중요한 정보는 재차 확인하세요. 쿠키 기본 설정을 참고하세요.
